#version 330 core


uniform struct Light {
	vec3 position;
	vec3 intensities; //the intensities of R,G,B respectively
} light;

struct PointLight {    
    vec3 position;
    
    float constant;
    float linear;
    float quadratic;  

    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};

uniform sampler2D texture0;
uniform mat4 MVP;
uniform numPointLights;
uniform PointLight pointLights[numPointLights];

in vec3 vertFrag;
in vec2 uvFrag;
in vec3 normFrag;

out vec4 color;

vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
		{
			vec3 lightDir = normalize(light.position - fragPos);
			// diffuse shading
			float diff = max(dot(normal, lightDir), 0.0);
			// specular shading
			vec3 reflectDir = reflect(-lightDir, normal);
			float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
			// attenuation
			float distance = length(light.position - fragPos);
			float attenuation = 1.0 / (light.constant + light.linear * distance +
				light.quadratic * (distance * distance));
			// combine results
			vec3 ambient = light.ambient  * vec3(texture(material.diffuse, TexCoords));
			vec3 diffuse = light.diffuse  * diff * vec3(texture(material.diffuse, TexCoords));
			vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));
			ambient *= attenuation;
			diffuse *= attenuation;
			specular *= attenuation;
			return (ambient + diffuse + specular);
		}

void main(){
	//calculate the normal of the vertex in world's vector space
	mat3 normalMat = transpose(inverse(mat3(MVP)));
	vec3 normal = normalize(normalMat * normFrag);

	//calculate position of the fragment in world's vector space
	vec3 posFrag = vec3(model * vec4(vertFrag, 1));
	vec3 vertToLight = light.pos - posFrag; //light vector

	//calculate cosine of light dir w/ respect to vertex
	float brightness = dot(normal, vertToLight) / (length(vertToLight) * length(normal));
	brightness = clamp(brightness, 0, 1); //keep values between 0 & 1

	// get color of texture mapped to this vertex being calculated
	color = texture(texture0, uv_Frag);
	//if(color.a < 0.5){
        //discard; //discard the color if alpha (the transparency ratio) < 0.5 
    //}
	color = vec4(brightness * light.intensities * color.rgb, color.a);
}

void main()
{
    // properties
    vec3 norm = normalize(Normal);
    vec3 viewDir = normalize(viewPos - FragPos);

    // phase 1: Directional lighting
    vec3 result = CalcDirLight(dirLight, norm, viewDir);
    // phase 2: Point lights
    for(int i = 0; i < NR_POINT_LIGHTS; i++)
        result += CalcPointLight(pointLights[i], norm, FragPos, viewDir);    
    // phase 3: Spot light
    //result += CalcSpotLight(spotLight, norm, FragPos, viewDir);    
    
    FragColor = vec4(result, 1.0);
}